<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Looping Dreams</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 40px;
            z-index: 2;
            color: rgba(255, 255, 255, 1.0);
            pointer-events: none;
            mix-blend-mode: exclusion;
        }

        /* 新增：中文标题样式 */
        .cn-title {
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 4px;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        /* 专辑名称标签 */
        #album-label {
            position: absolute;
            top: 73%;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 10;
            color: #ffffff;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0; 
            transition: opacity 0.5s ease;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            text-align: center;
            width: 80%;
        }
        
        #album-label span {
            display: block;
            font-size: 14px;
            opacity: 0.7;
            margin-top: 8px;
            letter-spacing: 2px;
            font-weight: normal;
        }

        /* 通用按钮样式 */
        .control-btn {
            position: absolute;
            width: 44px;
            height: 44px;
            z-index: 10;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s, transform 0.5s ease, background 0.3s;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.4);
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background: rgba(0, 0, 0, 0.6); 
            backdrop-filter: blur(4px);
            pointer-events: auto;
            padding: 0;
        }

        .control-btn:hover {
            opacity: 1.0;
            background: rgba(255, 255, 255, 0.1);
        }

        /* 重置按钮位置 */
        #reset-btn {
            top: 40px;
            left: 40px;
        }
        #reset-btn:hover {
            transform: rotate(-90deg);
        }

        /* 播放/暂停按钮位置 */
        #play-pause-btn {
            top: 100px; 
            left: 40px; 
        }
        #play-pause-btn:hover {
            transform: scale(1.1);
        }

        /* 特定专辑的播放按钮 */
        #track-play-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(108px, 108px); 
            z-index: 20;
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
            display: none;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s, background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #track-play-btn svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 26px;
            height: 26px;
            fill: none;
            stroke: #fff;
            stroke-width: 0; 
        }
        #track-icon-play path, #track-icon-pause path {
             fill: white; 
             stroke: none;
        }

        #track-play-btn:hover {
            transform: translate(108px, 108px) scale(1.1);
            background: rgba(255, 255, 255, 0.2);
        }

        /* 左上角控制按钮的 SVG */
        .control-btn svg {
            width: 26px;
            height: 26px;
            fill: none;
            stroke: #fff;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        h1 {
            font-weight: 300;
            font-size: 24px;
            letter-spacing: 6px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(255,255,255,0.6);
        }

        p {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        .instruction {
            margin-top: 24px;
            font-size: 10px;
            opacity: 0.9;
            border-left: 2px solid rgba(255,255,255,0.9);
            padding-left: 12px;
            line-height: 1.8;
            letter-spacing: 1px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <!-- 重置按钮 -->
    <div id="reset-btn" class="control-btn" title="Reset View">
        <svg viewBox="0 0 24 24">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
        </svg>
    </div>

    <!-- 全局播放/暂停按钮 (左上角) -->
    <div id="play-pause-btn" class="control-btn" title="Play/Pause Animation">
        <svg viewBox="0 0 24 24" id="icon-pause">
            <path d="M8 5v14M16 5v14" /> 
        </svg>
        <svg viewBox="0 0 24 24" id="icon-play" style="display: none;">
            <path d="M8 6l10 6l-10 6z" /> 
        </svg>
    </div>

    <!-- 12(0) 专属播放按钮 (默认隐藏) -->
    <div id="track-play-btn" title="Play Music" style="display: none;">
        <!-- 播放图标 -->
        <svg viewBox="0 0 24 24" id="track-icon-play" style="display: block;">
            <path d="M7 5l12 7l-12 7V5z" />
        </svg>
        <!-- 暂停图标 -->
        <svg viewBox="0 0 24 24" id="track-icon-pause" style="display: none;">
             <path d="M8 5h3v14H8zM13 5h3v14h-3z" />
        </svg>
    </div>

    <div id="album-label">
        ALBUM TITLE
        <span>ARTIST NAME</span>
    </div>

    <div id="ui-layer">
        <div class="cn-title">莫比乌斯电台</div>
        <h1>Looping Dreams</h1>
        <p>We are destined to cross again.</p>
        <div class="instruction">
            L-CLICK DRAG TO ROTATE<br>
            M-CLICK DRAG TO PAN<br>
            SCROLL TO ZOOM<br>
            CLICK TO FOCUS & FLIP
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- 粒子顶点着色器 -->
    <script type="x-shader/x-vertex" id="vertexShader">
        uniform float uTime;
        attribute float aRandom;
        attribute float aSize;
        attribute float aSpeed;
        attribute float aOffset; 
        attribute float aBandPosition; 
        varying float vAlpha;

        void main() {
            float speed = 0.15 + aSpeed * 0.02; 
            float t = uTime * speed + aOffset;
            float radius = 35.0;  
            float u = t; 
            float v = aBandPosition; 
            
            float cosU = cos(u);
            float sinU = sin(u);
            float cosHalfU = cos(u * 0.5);
            float sinHalfU = sin(u * 0.5);

            float x = (radius + v * cosHalfU) * cosU;
            float y = (radius + v * cosHalfU) * sinU;
            float z = v * sinHalfU;

            float wave = sin(u * 2.0); 
            z += wave * 5.0; 

            float hover = sin(uTime * 2.0 + aRandom * 10.0) * 0.5;
            x += hover * cosU;
            y += hover * sinU;

            vec3 pos = vec3(x, y, z);
            float angleX = 0.4; 
            float ca = cos(angleX);
            float sa = sin(angleX);
            vec3 posRotated = vec3(
                pos.x,
                pos.y * ca - pos.z * sa,
                pos.y * sa + pos.z * ca
            );

            vec4 mvPosition = modelViewMatrix * vec4(posRotated, 1.0);
            gl_PointSize = (aSize * 280.0) / -mvPosition.z;
            gl_Position = projectionMatrix * mvPosition;

            float alphaBase = 0.5 + 0.5 * sin(t * 2.0);
            vAlpha = 0.5 + 0.5 * alphaBase; 
        }
    </script>

    <!-- 粒子片元着色器 -->
    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform vec3 uColor;
        uniform float uGlobalAlpha; 
        varying float vAlpha;

        void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(gl_PointCoord, center);
            if (dist > 0.5) discard;
            float glow = 1.0 - (dist * 2.0);
            glow = pow(glow, 1.2); 
            gl_FragColor = vec4(uColor, vAlpha * glow * uGlobalAlpha);
        }
    </script>

    <script>
        // =========================================================
        //                 用户配置区
        // =========================================================

        const USE_LOCAL_ASSETS = true; 

        // 30组完整专辑数据
        const albumData = {
            "1(-7)": { title: "迷", artist: "（1994）" }, "1(-6)": { title: "天空", artist: "（1994）" }, "1(-5)": { title: "菲靡靡之音", artist: "（1995）" }, "1(-4)": { title: "浮躁", artist: "（1996）" }, "1(-3)": { title: "王菲", artist: "（1997）" }, "1(-2)": { title: "唱游", artist: "（1998）" }, "1(-1)": { title: "只爱陌生人", artist: "（1999）" }, "1(0)": { title: "寓言", artist: "（2000）" }, "1(1)": { title: "王菲", artist: "（2001）" }, "1(2)": { title: "将爱", artist: "（2003）" },
            "2(-5)": { title: "宠爱", artist: "（1995）" }, "2(-4)": { title: "红", artist: "（1996）" }, "2(-3)": { title: "这些年来", artist: "（1998）" }, "2(-2)": { title: "Printemps", artist: "（1998）" }, "2(-1)": { title: "陪你倒数", artist: "（1999）" }, "2(0)": { title: "大热", artist: "（2000）" }, "2(1)": { title: "untitled", artist: "（2000）" }, "2(2)": { title: "forever", artist: "（2001）" }, "2(3)": { title: "crossover", artist: "（2002）" }, "2(4)": { title: "一切随风", artist: "（2003）" },
            "3(-7)": { title: "爱上一个不回家的人", artist: "（1990）" }, "3(-6)": { title: "倾斜城市烧烧烧", artist: "（1990）" }, "3(-5)": { title: "open up", artist: "（1995）" }, "3(-4)": { title: "爱是唯一", artist: "（1996）" }, "3(-3)": { title: "夜太黑", artist: "（1996）" }, "3(-2)": { title: "美妙世界", artist: "（1997）" }, "3(-1)": { title: "铿锵玫瑰", artist: "（1999）" }, "3(0)": { title: "林忆莲' s", artist: "（2000）" }, "3(1)": { title: "原来…", artist: "（2001）" }, "3(2)": { title: "2001莲", artist: "（2001）" }, "3(3)": { title: "Encore", artist: "（2002）" }, "3(4)": { title: "本色", artist: "（2005）" },
            "4(-6)": { title: "情敌贝多芬", artist: "（1995）" }, "4(-5)": { title: "如果你听见我的歌", artist: "（1996）" }, "4(-4)": { title: "好想你", artist: "（1996）" }, "4(-3)": { title: "白纸", artist: "（1997）" }, "4(-2)": { title: "公转自转", artist: "（1998）" }, "4(-1)": { title: "不可能错过你", artist: "（1999）" }, "4(0)": { title: "永远的第一天", artist: "（2000）" }, "4(1)": { title: "唯一", artist: "（2001）" }, "4(2)": { title: "不可思议", artist: "（2003）" }, "4(3)": { title: "心中的日月", artist: "（2004）" },
            "5(-1)": { title: "David Tao", artist: "（1997）" }, "5(0)": { title: "I'm OK", artist: "（1999）" }, "5(1)": { title: "黑色柳丁", artist: "（2002）" }, "5(2)": { title: "太平盛世", artist: "（2005）" }, "5(3)": { title: "太美丽", artist: "（2006）" }, "5(4)": { title: "69乐章", artist: "（2009）" },
            "6(-7)": { title: "梦想", artist: "（1996）" }, "6(-6)": { title: "思念", artist: "（1996）" }, "6(-5)": { title: "挚爱", artist: "（1997）" }, "6(-4)": { title: "直觉", artist: "（1997）" }, "6(-3)": { title: "选哲", artist: "（1998）" }, "6(-2)": { title: "到处留情", artist: "（1998）" }, "6(-1)": { title: "回来", artist: "（1999）" }, "6(0)": { title: "信仰", artist: "（2000）" }, "6(1)": { title: "我好想", artist: "（2001）" }, "6(2)": { title: "从开始到现在", artist: "（2002）" }, "6(3)": { title: "下一个永远", artist: "（2004）" },
            "7(-3)": { title: "我们都是伤心人", artist: "（1993）" }, "7(-2)": { title: "生生世世", artist: "（1995）" }, "7(-1)": { title: "认识孙楠", artist: "（1997）" }, "7(0)": { title: "南极光", artist: "（1999）" }, "7(1)": { title: "楠得精选", artist: "（2001）" }, "7(2)": { title: "缘分的天空", artist: "（2002）" }, "7(3)": { title: "第一楠主角", artist: "（2003）" }, "7(4)": { title: "燃烧", artist: "（2004）" }, "7(5)": { title: "忘不了你", artist: "（2005）" },
            "8(-4)": { title: "为你朝思暮想", artist: "（1994）" }, "8(-3)": { title: "白天不懂夜的黑", artist: "（1995）" }, "8(-2)": { title: "征服", artist: "（1998）" }, "8(-1)": { title: "干脆", artist: "（1999）" }, "8(0)": { title: "心酸的浪漫", artist: "（1999）" }, "8(1)": { title: "我不是天使", artist: "（2001）" }, "8(2)": { title: "如今", artist: "（2002）" }, "8(3)": { title: "那英全经典演唱会", artist: "（2002）" },
            "9(-6)": { title: "生·生活", artist: "（1996）" }, "9(-5)": { title: "光阴似健", artist: "（1997）" }, "9(-4)": { title: "世界由你我开始", artist: "（1997）" }, "9(-3)": { title: "有故事的人", artist: "（1998）" }, "9(-2)": { title: "听健", artist: "（1998）" }, "9(-1)": { title: "至爱吾爱", artist: "（1999）" }, "9(0)": { title: "NOW 现在", artist: "（1999）" }, "9(1)": { title: "忘忧草", artist: "（2001）" }, "9(2)": { title: "遇见华健的感动", artist: "（2002）" }, "9(3)": { title: "My Favourite Songs", artist: "（2002）" }, "9(4)": { title: "爱上原味", artist: "（2002）" }, "9(5)": { title: "一起吃苦的幸福", artist: "（2003）" },
            "10(-4)": { title: "全身莫文蔚", artist: "（1996）" }, "10(-3)": { title: "做自己", artist: "（1997）" }, "10(-2)": { title: "我要说", artist: "（1998）" }, "10(-1)": { title: "你可以", artist: "（1999）" }, "10(0)": { title: "就是莫文蔚", artist: "（1999）" }, "10(1)": { title: "Karen More", artist: "（1999）" }, "10(2)": { title: "再生", artist: "（2000）" }, "10(3)": { title: "十二楼的莫文蔚", artist: "（2000）" }, "10(4)": { title: "一朵金花", artist: "（2001）" }, "10(5)": { title: "恋上莫文蔚", artist: "（2002）" },
            "11(-2)": { title: "赤裸裸", artist: "（1994）" }, "11(-1)": { title: "第三只眼", artist: "（1997）" }, "11(0)": { title: "怒放", artist: "（1999）" }, "11(1)": { title: "郑钧＝zj", artist: "（2001）" }, "11(2)": { title: "戈们的生活充满阳光", artist: "（2003）" }, "11(3)": { title: "长安长安", artist: "（2007）" },
            "12(0)": { title: "我去2000年", artist: "（1999）" }, "12(1)": { title: "生如夏花", artist: "（2003）" },
            "13(-1)": { title: "第一张创作专辑", artist: "（1999）" }, "13(0)": { title: "爱情万岁", artist: "（2000）" }, "13(1)": { title: "人生海海", artist: "（2001）" }, "13(2)": { title: "时光机", artist: "（2003）" }, "13(3)": { title: "神的孩子都在跳舞", artist: "（2004）" }, "13(4)": { title: "为爱而生", artist: "（2006）" }, "13(5)": { title: "后青春期的诗", artist: "（2008）" },
            "14(-7)": { title: "狼来了", artist: "（1996）" }, "14(-6)": { title: "直觉", artist: "（1997）" }, "14(-5)": { title: "私日记", artist: "（1997）" }, "14(-4)": { title: "到此一游", artist: "（1998）" }, "14(-3)": { title: "体验入学", artist: "（1998）" }, "14(-2)": { title: "夏天的故事", artist: "（1999）" }, "14(-1)": { title: "微笑", artist: "（1999）" }, "14(0)": { title: "冬天的故事", artist: "（1999）" }, "14(1)": { title: "Play It Loud,Kiss Me Soft", artist: "（2000）" }, "14(2)": { title: "Miriam", artist: "（2001）" }, "14(3)": { title: "MvsM上半场", artist: "（2002）" }, "14(4)": { title: "MvsM 下半场", artist: "（2002）" },
            "15(-7)": { title: "小魔女的魔法书", artist: "（1996）" }, "15(-6)": { title: "冰淇淋的祈祷", artist: "（1996）" }, "15(-5)": { title: "好想谈恋爱", artist: "（1996）" }, "15(-4)": { title: "小魔女变身舞曲 第1变舞法无天", artist: "（1997）" }, "15(-3)": { title: "小魔女魔法书 第2 辑魔登家庭", artist: "（1997）" }, "15(-2)": { title: "圣诞快乐 SONG", artist: "（1997）" }, "15(-1)": { title: "我要我们在一起", artist: "（1999）" }, "15(0)": { title: "绝世名伶", artist: "（1999）" }, "15(1)": { title: "星星", artist: "（2001）" }, "15(2)": { title: "我要我们的范晓萱", artist: "（2004）" },
            "16(-4)": { title: "少女小渔刘若英的美丽与哀愁", artist: "（1995）" }, "16(-3)": { title: "雨季", artist: "（1995）" }, "16(-2)": { title: "到处乱走", artist: "（1996）" }, "16(-1)": { title: "很爱很爱你", artist: "（1998）" }, "16(0)": { title: "我等你", artist: "（2000）" }, "16(1)": { title: "年华", artist: "（2001）" }, "16(2)": { title: "Love and theCity", artist: "（2002）" }, "16(3)": { title: "我的失败与伟大", artist: "（2003）" }, "16(4)": { title: "听说？", artist: "（2004）" }, "16(5)": { title: "一整夜", artist: "（2005）" },
            "17(-5)": { title: "消息", artist: "（1996）" }, "17(-4)": { title: "整个八月", artist: "（1997）" }, "17(-3)": { title: "温古知新·一个人的天荒地老", artist: "（1997）" }, "17(-2)": { title: "单恋", artist: "（1998）" }, "17(-1)": { title: "月亮太阳", artist: "（1998）" }, "17(0)": { title: "雨一直下", artist: "（1999）" }, "17(1)": { title: "奇迹创世纪精选", artist: "（2000）" }, "17(2)": { title: "替身", artist: "（2001）" }, "17(3)": { title: "大丈夫", artist: "（2003）" }, "17(4)": { title: "不甘寂寞", artist: "（2004）" },
            "18(-1)": { title: "让我想一想", artist: "（1998）" }, "18(0)": { title: "还是会寂寞", artist: "（2000）" }, "18(1)": { title: "Groupies 吉他手", artist: "（2002）" }, "18(2)": { title: "After 17", artist: "（2004）" }, "18(3)": { title: "华丽的冒险", artist: "（2005）" },
            "19(-5)": { title: "寻最", artist: "（1996）" }, "19(-4)": { title: "情牢", artist: "（1997）" }, "19(-3)": { title: "在克勤身边", artist: "（1997）" }, "19(-2)": { title: "98新曲+精选", artist: "（1998）" }, "19(-1)": { title: "一年半载", artist: "（1999）" }, "19(0)": { title: "再一次想你", artist: "（2000）" }, "19(1)": { title: "飞花", artist: "（2001）" }, "19(2)": { title: "李克勤大乐队", artist: "（2002）" }, "19(3)": { title: "Let's Celebrate", artist: "（2002）" }, "19(4)": { title: "Ever Last", artist: "（2002）" },
            "20(-5)": { title: "依靠", artist: "（1997）" }, "20(-4)": { title: "心太软", artist: "（1997）" }, "20(-3)": { title: "很受伤", artist: "（1997）" }, "20(-2)": { title: "爱像太平洋", artist: "（1998）" }, "20(-1)": { title: "认真精选辑", artist: "（1999）" }, "20(0)": { title: "为爱走天涯", artist: "（2000）" }, "20(1)": { title: "天使兄弟小白脸", artist: "（2000）" }, "20(2)": { title: "飞鸟", artist: "（2000）" }, "20(3)": { title: "一个任贤齐", artist: "（2002）" },
            "21(0)": { title: "Jay", artist: "（2000）" }, "21(1)": { title: "范特西", artist: "（2001）" }, "21(2)": { title: "八度空间", artist: "（2002）" }, "21(3)": { title: "叶惠美", artist: "（2003）" }, "21(4)": { title: "七里香", artist: "（2004）" }, "21(5)": { title: "11月的萧邦", artist: "（2005）" }, "21(6)": { title: "依然范特西", artist: "（2006）" }, "21(7)": { title: "我很忙", artist: "（2007）" },
            "22(-1)": { title: "Jolin1019", artist: "（1999）" }, "22(0)": { title: "Don't Stop", artist: "（2000）" }, "22(1)": { title: "Show Your Love", artist: "（2000）" }, "22(2)": { title: "Lucky Number", artist: "（2001）" }, "22(3)": { title: "看我 72变", artist: "（2003）" }, "22(4)": { title: "城堡", artist: "（2004）" }, "22(5)": { title: "J-Game", artist: "（2005）" }, "22(6)": { title: "特务J", artist: "（2006）" },
            "23(-6)": { title: "爱自己", artist: "（1996）" }, "23(-5)": { title: "短发", artist: "（1997）" }, "23(-4)": { title: "新居", artist: "（1997）" }, "23(-3)": { title: "洗脸", artist: "（1997）" }, "23(-2)": { title: "新鲜", artist: "（1999）" }, "23(-1)": { title: "I'll Be Loving You", artist: "（1999）" }, "23(0)": { title: "最爱", artist: "（2000）" }, "23(1)": { title: "Kiss", artist: "（2000）" }, "23(2)": { title: "花火", artist: "（2000）" }, "23(3)": { title: "Amour", artist: "（2001）" }, "23(4)": { title: "Suddenly, this summer", artist: "（2001）" },
            "24(-4)": { title: "就是喜欢你", artist: "（1993）" }, "24(-3)": { title: "花开了没有", artist: "（1994）" }, "24(-2)": { title: "这个下午很无聊", artist: "（1997）" }, "24(-1)": { title: "秘密基地", artist: "（1998）" }, "24(0)": { title: "有问题", artist: "（2000）" }, "24(1)": { title: "Orange 2", artist: "（2001）" }, "24(2)": { title: "等我有一天", artist: "（2002）" },
            "25(0)": { title: "幸福的旁边", artist: "（1999）" }, "25(1)": { title: "草莓声明", artist: "（2001）" }, "25(2)": { title: "我是你的罗密欧", artist: "（2004）" }, "25(3)": { title: "花季王朝", artist: "（2005）" }, "25(4)": { title: "花天囍世", artist: "（2005）" }, "25(5)": { title: "花龄盛会", artist: "（2007）" },
            "26(-5)": { title: "姐妹", artist: "（1996）" }, "26(-4)": { title: "BAD BOY", artist: "（1997）" }, "26(-3)": { title: "妹力四射", artist: "（1997）" }, "26(-2)": { title: "牵手", artist: "（1998）" }, "26(-1)": { title: "我可以抱你吗？爱人", artist: "（1999）" }, "26(0)": { title: "歌声妹影", artist: "（2000）" }, "26(1)": { title: "不顾一切", artist: "（2000）" }, "26(2)": { title: "旅程", artist: "（2000）" }, "26(3)": { title: "真实", artist: "（2001）" }, "26(4)": { title: "发烧", artist: "（2002）" },
            "27(-3)": { title: "浪人情歌", artist: "（1994）" }, "27(-2)": { title: "爱情的尽头", artist: "（1996）" }, "27(-1)": { title: "树枝孤鸟", artist: "（1998）" }, "27(0)": { title: "白鸽", artist: "（1999）" }, "27(1)": { title: "梦的河流", artist: "（2001）" }, "27(2)": { title: "泪桥", artist: "（2003）" }, "27(3)": { title: "双面人", artist: "（2005）" }, "27(4)": { title: "快乐练习曲", artist: "（2006）" },
            "28(-1)": { title: "一夜长大", artist: "（1999）" }, "28(0)": { title: "勇气", artist: "（2000）" }, "28(1)": { title: "闪亮的星", artist: "（2001）" }, "28(2)": { title: "Sunrise 我喜欢", artist: "（2002）" }, "28(3)": { title: "美丽人生", artist: "（2003）" }, "28(4)": { title: "燕尾蝶", artist: "（2004）" }, "28(5)": { title: "丝路", artist: "（2005）" }, "28(6)": { title: "亲亲", artist: "（2006）" },
            "29(-1)": { title: "新裤子", artist: "（1999）" }, "29(0)": { title: "Disco Girl", artist: "（2000）" }, "29(1)": { title: "我们是自动的", artist: "（2002）" }, "29(2)": { title: "龙虎人丹", artist: "（2006）" },
            "30(0)": { title: "孙燕姿", artist: "（2000）" }, "30(1)": { title: "我要的幸福", artist: "（2000）" }, "30(2)": { title: "风筝", artist: "（2001）" }, "30(3)": { title: "Leave", artist: "（2002）" }, "30(4)": { title: "未完成", artist: "（2003）" }, "30(5)": { title: "The Moment", artist: "（2003）" }, "30(6)": { title: "完美的一天", artist: "（2005）" }, "30(7)": { title: "逆光", artist: "（2007）" }
        };

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const DEFAULT_CAM_Z = 75;
        const DEFAULT_CAM_Y = -2;
        const MIN_ZOOM = 20; 
        const MAX_ZOOM = 120;
        
        camera.position.z = DEFAULT_CAM_Z;
        camera.position.y = DEFAULT_CAM_Y;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- 音频管理器 ---
        const audioManager = {
            current: null,
            trackPlayBtn: document.getElementById('track-play-btn'),
            iconPlay: document.getElementById('track-icon-play'),
            iconPause: document.getElementById('track-icon-pause'),
            
            isPlaying: false,

            init: function() {
                 this.trackPlayBtn.addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.isPlaying) {
                         this.pause();
                     } else {
                         this.playCurrent();
                     }
                 });
                 // 防止点击播放键穿透到场景
                 this.trackPlayBtn.addEventListener('mousedown', e => e.stopPropagation());
                 this.trackPlayBtn.addEventListener('touchstart', e => e.stopPropagation());
            },

            load: function(id) {
                // 停止当前播放（如果正在播放）
                this.stop();
                
                // 设置新音源路径，但不自动播放
                const audioPath = `assets/12/12(01).mp3`; 
                // 注意：这里暂时硬编码为用户指定的 12(01).mp3 用于演示
                // 如果要通用化，应该基于 id 动态生成，例如: `assets/${id+1}/${id+1}(01).mp3`
                
                this.current = new Audio(audioPath);
                this.current.volume = 0.6;
                
                // 错误处理
                this.current.onerror = () => {
                    console.log("Audio not found or error loading.");
                    this.isPlaying = false;
                    this.updateIcon();
                };
                
                // 监听播放结束，重置图标
                this.current.onended = () => {
                    this.isPlaying = false;
                    this.updateIcon();
                };
            },

            playCurrent: function() {
                if (this.current) {
                    this.current.play().then(() => {
                        this.isPlaying = true;
                        this.updateIcon();
                    }).catch(e => {
                        console.log("Play failed:", e);
                    });
                }
            },

            pause: function() {
                if (this.current) {
                    this.current.pause();
                    this.isPlaying = false;
                    this.updateIcon();
                }
            },

            stop: function() {
                if (this.current) {
                    this.current.pause();
                    this.current.currentTime = 0;
                }
                this.isPlaying = false;
                this.updateIcon();
            },
            
            updateIcon: function() {
                if (this.isPlaying) {
                    this.iconPlay.style.display = 'none';
                    this.iconPause.style.display = 'block';
                } else {
                    this.iconPlay.style.display = 'block';
                    this.iconPause.style.display = 'none';
                }
            },
            
            showButton: function() {
                // 确保flex居中
                this.trackPlayBtn.style.display = 'flex'; 
                this.updateIcon(); 
            },
            
            hideButton: function() {
                this.trackPlayBtn.style.display = 'none';
                this.stop(); // 隐藏按钮时同时也停止音乐
            }
        };
        
        audioManager.init();

        // --- 1. 背景粒子系统 (基于包络线生成) ---
        const particleCount = 20000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const randoms = new Float32Array(particleCount);
        const sizes = new Float32Array(particleCount);
        const speeds = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        const bandPositions = new Float32Array(particleCount);

        const initialParticleColor = new THREE.Color(0xffffff);
        const particleMaterial = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: initialParticleColor },
                uGlobalAlpha: { value: 1.0 } 
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        // --- 2. 纹理生成 ---
        const textureLoader = new THREE.TextureLoader();

        function getHslColorString(index) {
            const hue = (index * 12) % 360; 
            return `hsl(${hue}, 70%, 50%)`;
        }

        function createCardTexture(text, colorIndex, groupIndex, type, stackIndex) {
            if (USE_LOCAL_ASSETS) {
                const n = groupIndex;
                let filename = '';

                if (type === 'main') {
                    filename = `${n}(0).jpg`;
                } else if (type === 'down') { 
                    filename = `${n}(${stackIndex}).jpg`;
                } else if (type === 'up') { 
                    filename = `${n}(-${stackIndex}).jpg`;
                }

                const path = `assets/${n}/${filename}`;
                
                const tex = textureLoader.load(path, 
                    () => {}, undefined, (err) => {}
                );
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                return tex;
            }

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const color = getHslColorString(colorIndex);
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 20;
            ctx.strokeRect(10, 10, 492, 492);
            ctx.fillStyle = '#fff';
            const fontSize = text.length > 3 ? 120 : 200;
            ctx.font = `bold ${fontSize}px Helvetica`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 10;
            ctx.fillText(text, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }

        const helloTexture = (function() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#000000';
            ctx.font = "italic 40px Helvetica"; 
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("hello world", 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        })();

        // --- 3. 专辑构建 & 边界计算 ---
        const albums = []; 
        const albumGroup = new THREE.Group();
        scene.add(albumGroup);

        const boxGeometry = new THREE.BoxGeometry(4, 4, 0.1); 
        const sideMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 

        // 收集每组的边界信息 { u, vMin, vMax }
        const groupBoundaries = []; 

        function createCard(u, vOffset, label, colorIndex, groupIndex, type, stackIndex) {
            const containerGroup = new THREE.Group();
            
            const mainTexture = createCardTexture(label, colorIndex, groupIndex, type, stackIndex);
            const mainMaterial = new THREE.MeshBasicMaterial({ map: mainTexture });

            const materials = [
                sideMaterial, sideMaterial, sideMaterial, sideMaterial,
                mainMaterial, 
                mainMaterial  
            ];

            const mesh = new THREE.Mesh(boxGeometry, materials);
            containerGroup.add(mesh);

            containerGroup.userData = {
                u: u,
                offsetY: vOffset,
                posIndex: colorIndex, 
                groupId: groupIndex,  
                colorIndex: colorIndex, 
                labelText: label,
                isFlipped: false, 
                currentScale: 1.0, 
                originalMaterial: mainMaterial, 
                innerMesh: mesh,
                cardType: type
            };
            
            albumGroup.add(containerGroup);
            albums.push(containerGroup);
        }

        const albumCount = 30;
        const spacing = 5.0;

        // 定义排序后的组别顺序 (根据专辑数量从小到大)
        const groupOrder = [
            12, 
            29, 
            18, 
            5, 11, 25, 
            13, 24, 
            8, 21, 22, 27, 28, 30, 
            7, 20, 
            1, 2, 4, 10, 15, 16, 17, 19, 26, 
            6, 23, 
            3, 9, 14
        ];

        // --- 生成所有专辑并记录边界 ---
        for (let i = 0; i < albumCount; i++) {
            const visualAngle = (i / albumCount) * Math.PI * 2; 
            const u = (i % 2 === 1) ? visualAngle + Math.PI * 2 : visualAngle;
            
            const n = groupOrder[i];
            
            // 计算该组的上下边界
            let minM = 0;
            let maxM = 0;

            // 检查向下延伸
            for (let m = 1; m <= 15; m++) {
                if (albumData[`${n}(${m})`]) maxM = m;
                else break;
            }
            // 检查向上延伸
            for (let m = 1; m <= 15; m++) {
                if (albumData[`${n}(-${m})`]) minM = -m;
                else break;
            }

            // 记录边界（加一点余量让粒子包裹住）
            groupBoundaries.push({
                u: u,
                vMin: (Math.min(0, minM) * spacing) - 2.0,
                vMax: (Math.max(0, maxM) * spacing) + 2.0
            });

            // 生成实际卡片
            createCard(u, 0, `${n}(0)`, i, n, 'main', 0);

            for (let m = 1; m <= maxM; m++) {
                createCard(u, spacing * m, `${n}(${m})`, i, n, 'down', m);
            }
            for (let m = 1; m <= Math.abs(minM); m++) {
                createCard(u, -spacing * m, `${n}(-${m})`, i, n, 'up', m);
            }
        }

        // --- 构建插值曲线 ---
        // 1. 按 u 排序
        groupBoundaries.sort((a, b) => a.u - b.u);

        // 2. 粒子生成：使用线性插值
        function getBoundaryAt(targetU) {
            // Wrap u to 0-4PI
            let u = targetU % (4 * Math.PI);
            if (u < 0) u += 4 * Math.PI;

            let p1 = groupBoundaries[groupBoundaries.length - 1];
            let p2 = groupBoundaries[0];
            
            for (let i = 0; i < groupBoundaries.length - 1; i++) {
                if (u >= groupBoundaries[i].u && u < groupBoundaries[i+1].u) {
                    p1 = groupBoundaries[i];
                    p2 = groupBoundaries[i+1];
                    break;
                }
            }
            
            let u1 = p1.u;
            let u2 = p2.u;
            
            if (u2 < u1) { 
                 u2 += 4 * Math.PI;
                 if (u < u1) u += 4 * Math.PI; 
            }

            const tLinear = (u - u1) / (u2 - u1);
            const t = tLinear * tLinear * (3 - 2 * tLinear); // Smoothstep
            
            const vMin = p1.vMin + (p2.vMin - p1.vMin) * t;
            const vMax = p1.vMax + (p2.vMax - p1.vMax) * t;
            
            return { vMin, vMax };
        }

        // --- 生成粒子 (梯形分布) ---
        const fadeMargin = 15.0; // 渐变边缘宽度

        for (let i = 0; i < particleCount; i++) {
            positions[i] = 0; positions[i+1] = 0; positions[i+2] = 0;
            randoms[i] = Math.random();
            sizes[i] = Math.random() < 0.2 ? Math.random() * 1.5 + 0.5 : Math.random();
            speeds[i] = 0.15 + (Math.random() - 0.5) * 0.02; 
            
            const u = Math.random() * 4 * Math.PI;
            offsets[i] = u;
            
            const bounds = getBoundaryAt(u);
            const coreHeight = bounds.vMax - bounds.vMin;
            
            // 总概率区间长度 = 核心高度 + 边缘渐变等效高度 (三角形面积=0.5*底*高, 高是概率密度1.0)
            const totalArea = coreHeight + fadeMargin;
            
            const r = Math.random() * totalArea;
            
            if (r < coreHeight) {
                bandPositions[i] = bounds.vMin + r;
            } else {
                const dist = fadeMargin * (1.0 - Math.sqrt(Math.random()));
                if (Math.random() < 0.5) {
                    bandPositions[i] = bounds.vMax + dist;
                } else {
                    bandPositions[i] = bounds.vMin - dist;
                }
            }
        }

        // 更新 BufferAttribute
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));
        geometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));
        geometry.setAttribute('aBandPosition', new THREE.BufferAttribute(bandPositions, 1));

        // 创建粒子系统
        const particleSystemFinal = new THREE.Points(geometry, particleMaterial);
        particleSystemFinal.frustumCulled = false;
        scene.add(particleSystemFinal);


        function getMobiusPosition(u, v) {
            const radius = 35.0;
            const wave = Math.sin(u * 2.0) * 5.0;
            const cosHalfU = Math.cos(u * 0.5);
            const sinHalfU = Math.sin(u * 0.5);
            const cosU = Math.cos(u);
            const sinU = Math.sin(u);

            const x = (radius + v * cosHalfU) * cosU;
            const y = (radius + v * cosHalfU) * sinU;
            const z = v * sinHalfU + wave;

            const angleX = 0.4;
            const ca = Math.cos(angleX);
            const sa = Math.sin(angleX);
            
            return new THREE.Vector3(x, y * ca - z * sa, y * sa + z * ca);
        }

        // --- 4. 交互核心 ---
        let targetRotationX = 0;
        let targetRotationY = 0;
        let mouseX = 0; 
        let mouseY = 0;
        
        let isDragging = false;
        let isPanning = false; 
        
        // 关键变量：记录“点击时刻”和“上一帧拖拽时刻”的位置
        let dragStartPos = { x: 0, y: 0 }; // 仅在 mousedown 更新，用于判定 totalDragDistance
        let lastMovePos = { x: 0, y: 0 };  // 在 mousedown 和 mousemove 更新，用于计算 delta
        
        let simulatedTime = 0; 
        let isFocused = false; 
        let focusedAlbum = null; 
        let isGlobalPaused = false; 
        
        let camTargetPos = new THREE.Vector3(0, DEFAULT_CAM_Y, DEFAULT_CAM_Z);
        let camLookAtPos = new THREE.Vector3(0, 0, 0);
        let camTargetUp = new THREE.Vector3(0, 1, 0);

        // 新增：聚焦时的轨道旋转角度
        let focusRotX = 0;
        let focusRotY = 0;

        let targetGlobalAlpha = 1.0;
        let currentGlobalAlpha = 1.0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const albumLabelEl = document.getElementById('album-label');

        function resetGlobalView() {
            if (focusedAlbum) {
                resetFlip(focusedAlbum);
            }

            // --- 新增：恢复所有卡片的正常深度遮挡关系和可见性 ---
            albums.forEach(group => {
                group.visible = true; // 恢复可见
                const mesh = group.userData.innerMesh;
                mesh.renderOrder = 0; 
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.depthTest = true); 
                } else {
                    mesh.material.depthTest = true;
                }
            });
            // ------------------------------------------

            isFocused = false;
            focusedAlbum = null;

            camTargetPos.set(0, DEFAULT_CAM_Y, DEFAULT_CAM_Z);
            camLookAtPos.set(0, 0, 0);
            camTargetUp.set(0, 1, 0);

            targetRotationX = 0;
            targetRotationY = 0;
            
            targetGlobalAlpha = 1.0;
            albumLabelEl.style.opacity = '0';
            audioManager.stop();
            audioManager.hideButton(); // 确保隐藏按钮
        }

        document.getElementById('reset-btn').addEventListener('click', (e) => {
            e.stopPropagation(); 
            resetGlobalView();
        });

        // --- 播放/暂停按钮逻辑 ---
        const playPauseBtn = document.getElementById('play-pause-btn');
        const iconPause = document.getElementById('icon-pause');
        const iconPlay = document.getElementById('icon-play');

        playPauseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            isGlobalPaused = !isGlobalPaused;
            if (isGlobalPaused) {
                iconPause.style.display = 'none';
                iconPlay.style.display = 'block';
            } else {
                iconPause.style.display = 'block';
                iconPlay.style.display = 'none';
            }
        });

        function onStart(e) {
            // 如果点击的是 UI 控件，则不触发场景拖拽
            if (e.target.closest('.control-btn') || e.target.closest('#track-play-btn')) return;

            if (e.button === 0) {
                isDragging = true;
            } else if (e.button === 1) {
                isPanning = true;
                e.preventDefault(); 
            }
            
            // 初始化记录点
            dragStartPos = { x: e.clientX, y: e.clientY };
            lastMovePos = { x: e.clientX, y: e.clientY };
        }

        function onEnd(e) {
            // 如果是 UI 控件释放，也不触发场景逻辑
             if (e.target.closest('.control-btn') || e.target.closest('#track-play-btn')) return;

            if (isDragging) {
                isDragging = false;
                // 使用 dragStartPos 计算总移动距离，判定是否为点击
                const dist = Math.sqrt(Math.pow(e.clientX - dragStartPos.x, 2) + Math.pow(e.clientY - dragStartPos.y, 2));
                
                // 阈值设为 10px，小于此值视为点击
                if (dist < 10 && e.button === 0) {
                    handleClick(e.clientX, e.clientY);
                }
            }
            if (isPanning) {
                isPanning = false;
            }
        }
        
        function onWheel(e) {
            if (isFocused) return; 
            e.preventDefault();
            const zoomSpeed = 0.1;
            let newZ = camTargetPos.z + e.deltaY * zoomSpeed;
            newZ = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZ));
            camTargetPos.z = newZ;
        }

        function onMove(e) {
             if (e.target.closest('.control-btn') || e.target.closest('#track-play-btn')) return;

            const clientX = e.clientX;
            const clientY = e.clientY;
            mouseX = (clientX / window.innerWidth) * 2 - 1;
            mouseY = -(clientY / window.innerHeight) * 2 + 1;

            // 计算与上一帧的偏移量
            const deltaX = clientX - lastMovePos.x;
            const deltaY = clientY - lastMovePos.y;

            if (isDragging) {
                if (!isFocused) {
                    // 全局旋转
                    targetRotationY += deltaX * 0.005;
                    targetRotationX += deltaY * 0.005;
                } else {
                    // 聚焦时：轨道旋转 (Orbit around card)
                    focusRotY -= deltaX * 0.005;
                    focusRotX -= deltaY * 0.005;
                    // 限制上下旋转角度，防止翻转
                    focusRotX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, focusRotX));
                }
            } else if (isPanning && !isFocused) { 
                const panSpeed = 0.05;
                camTargetPos.x -= deltaX * panSpeed;
                camTargetPos.y += deltaY * panSpeed; 
                camLookAtPos.x -= deltaX * panSpeed;
                camLookAtPos.y += deltaY * panSpeed;
            }

            // 更新上一帧位置，供下一次 delta 计算
            lastMovePos = { x: clientX, y: clientY };
        }

        function handleClick(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            scene.updateMatrixWorld();
            const allMeshes = [];
            albums.forEach(group => {
                if(group.visible) allMeshes.push(group.userData.innerMesh);
            });
            const intersects = raycaster.intersectObjects(allMeshes);

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const clickedGroup = clickedMesh.parent; 
                if (!isFocused) {
                    focusOnAlbum(clickedGroup);
                } else {
                    if (clickedGroup === focusedAlbum) {
                        toggleFlip(clickedGroup);
                    } else {
                        // 切换聚焦前先重置 visibility
                        resetGlobalView();
                        // 下一帧再聚焦，或直接重置状态
                        // 简单处理：直接聚焦新卡片，focusOnAlbum 会处理隐藏逻辑
                        focusOnAlbum(clickedGroup);
                    }
                }
            } else {
                if (isFocused) resetGlobalView(); 
            }
        }

        function toggleFlip(group) {
            const mesh = group.userData.innerMesh;
            group.userData.isFlipped = !group.userData.isFlipped;
            if (group.userData.isFlipped) {
                if (Array.isArray(mesh.material)) {
                    mesh.material[5] = new THREE.MeshBasicMaterial({ map: helloTexture });
                }
            }
        }

        function resetFlip(group) {
            if (!group) return;
            group.userData.isFlipped = false;
            const mesh = group.userData.innerMesh;
            if (Array.isArray(mesh.material)) {
                mesh.material[5] = group.userData.originalMaterial;
            }
            mesh.rotation.y = 0;
        }

        function focusOnAlbum(group) {
            isFocused = true;
            focusedAlbum = group;
            targetGlobalAlpha = 0.0;
            
            // 重置轨道旋转角度
            focusRotX = 0;
            focusRotY = 0;

            scene.updateMatrixWorld();
            const worldPos = new THREE.Vector3();
            group.getWorldPosition(worldPos);
            const worldQuat = new THREE.Quaternion();
            group.getWorldQuaternion(worldQuat);
            const worldNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(worldQuat);
            const worldUp = new THREE.Vector3(0, 1, 0).applyQuaternion(worldQuat);

            camLookAtPos.copy(worldPos);
            const distance = 8.0; 
            camTargetPos.copy(worldPos).add(worldNormal.multiplyScalar(distance));
            camTargetUp.copy(worldUp);

            // --- 智能遮挡剔除 (Smart Occlusion Culling) ---
            // 1. 先让所有卡片可见
            albums.forEach(g => g.visible = true);
            
            // 2. 定义目标卡片上的关键检测点 (中心 + 四角)
            // 卡片大小是 4x4, 我们检测稍微向内一点的范围(1.8)以防边缘误差
            const checkPointsLocal = [
                new THREE.Vector3(0, 0, 0),    // 中心
                new THREE.Vector3(1.8, 1.8, 0),  // 右上
                new THREE.Vector3(-1.8, 1.8, 0), // 左上
                new THREE.Vector3(1.8, -1.8, 0), // 右下
                new THREE.Vector3(-1.8, -1.8, 0) // 左下
            ];

            // 3. 获取所有 Mesh 用于检测 (排除当前的)
            const allMeshes = albums.map(g => g.userData.innerMesh);
            const targetMesh = group.userData.innerMesh;

            // 4. 发射射线检测遮挡
            const occlusionRaycaster = new THREE.Raycaster();
            const blockers = new Set(); // 用 Set 存储被标记为遮挡的组(去重)

            checkPointsLocal.forEach(localPoint => {
                // 将局部坐标转为世界坐标
                const targetPoint = localPoint.clone().applyMatrix4(targetMesh.matrixWorld);
                
                // 计算射线方向：从相机目标位置 -> 卡片上的点
                const direction = new THREE.Vector3().subVectors(targetPoint, camTargetPos).normalize();
                
                // 设置射线：起点是相机目标位置
                occlusionRaycaster.set(camTargetPos, direction);
                
                // 检测相交
                // far 设置为到目标点的距离，稍微大一点点以容错，但不要射穿到后面去
                occlusionRaycaster.far = camTargetPos.distanceTo(targetPoint) + 0.1;
                
                const intersects = occlusionRaycaster.intersectObjects(allMeshes);
                
                for (let hit of intersects) {
                    // 如果射到了目标自己，说明这条线上没障碍了（或者穿过了障碍到了目标）
                    // 这里的逻辑是：intersects 是按距离排序的
                    // 如果第一个打到的不是目标，那就是遮挡物
                    if (hit.object === targetMesh) {
                        // 到了目标，这条射线检测结束
                        break; 
                    } else {
                        // 打到了别的物体，这就是遮挡物！
                        // 把它所属的 Group 加入黑名单
                        blockers.add(hit.object.parent);
                    }
                }
            });

            // 5. 隐藏所有遮挡物
            blockers.forEach(g => g.visible = false);
            // ----------------------------------------------------

            const label = group.userData.labelText; 
            const info = albumData[label] || { 
                title: `ALBUM ${label}`, 
                artist: `ARTIST No.${group.userData.groupId}` 
            };

            albumLabelEl.innerHTML = `${info.title}<br><span>${info.artist}</span>`;
            albumLabelEl.style.opacity = '1';

            if (group.userData.labelText === "12(0)") {
                audioManager.load(group.userData.groupId);
                audioManager.showButton();
            } else {
                audioManager.hideButton();
            }
        }

        // --- 监听器 ---
        document.addEventListener('mousedown', onStart);
        document.addEventListener('mouseup', onEnd);
        document.addEventListener('mousemove', onMove);
        document.addEventListener('wheel', onWheel, { passive: false }); 

        document.addEventListener('touchstart', e => {
            if (e.target.closest('#reset-btn') || e.target.closest('#play-pause-btn') || e.target.closest('#track-play-btn')) return;
            onStart({ button: 0, clientX: e.touches[0].clientX, clientY: e.touches[0].clientY, preventDefault: () => {} });
        }, {passive: false});
        document.addEventListener('touchend', e => {
             if (e.target.closest('#reset-btn') || e.target.closest('#play-pause-btn') || e.target.closest('#track-play-btn')) return;
             const touch = e.changedTouches[0];
             onEnd({ button: 0, clientX: touch.clientX, clientY: touch.clientY });
        });
        document.addEventListener('touchmove', e => {
            if (e.target.closest('#reset-btn') || e.target.closest('#play-pause-btn') || e.target.closest('#track-play-btn')) return;
            onMove({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
            e.preventDefault();
        }, {passive: false});

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();
        const currentLookAt = new THREE.Vector3(0, 0, 0);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 自动旋转逻辑：无人操作且未聚焦时
            if (!isFocused && !isDragging && !isPanning && !isGlobalPaused) {
                simulatedTime += delta;
                
                // 恢复自动旋转：仅在无人操作时自动旋转
                targetRotationY += 0.0005; 
                targetRotationX += 0.0002;
            }
            particleMaterial.uniforms.uTime.value = simulatedTime;

            // --- 粒子透明度渐变 ---
            currentGlobalAlpha += (targetGlobalAlpha - currentGlobalAlpha) * 0.05;
            particleMaterial.uniforms.uGlobalAlpha.value = currentGlobalAlpha;

            albums.forEach((group) => {
                // 如果不可见，为了性能可以跳过大部分逻辑，但位置计算仍需保持同步
                // 为了简单，我们只跳过渲染相关的更新，位置逻辑保持
                const mesh = group.userData.innerMesh;
                
                // 如果未暂停，更新专辑位置
                if (!isFocused && !isDragging && !isPanning && !isGlobalPaused) {
                    group.userData.u += delta * 0.15; 
                }
                if (group.userData.u > Math.PI * 4) group.userData.u -= Math.PI * 4;

                const u = group.userData.u;
                const v = group.userData.offsetY; 

                const pos = getMobiusPosition(u, v); 
                const lookAtPos = getMobiusPosition(u + 0.1, v);

                group.position.copy(pos);
                group.lookAt(lookAtPos);
                group.rotateY(Math.PI / 2); 
                group.rotateX(u * 0.5); 
                
                if (group.userData.posIndex % 2 === 1) {
                    group.rotateX(Math.PI); 
                }
                
                const targetFlip = group.userData.isFlipped ? Math.PI : 0;
                const currentRot = mesh.rotation.y;
                mesh.rotation.y += (targetFlip - currentRot) * 0.1;
                
                if (!group.userData.isFlipped && Math.abs(mesh.rotation.y) < 0.1) {
                    if (Array.isArray(mesh.material) && mesh.material[5] !== group.userData.originalMaterial) {
                        mesh.material[5] = group.userData.originalMaterial;
                    }
                }

                let targetScale = 1.0; 
                if (isFocused) {
                    if (group === focusedAlbum) {
                        targetScale = 1.2; 
                    } else {
                        targetScale = 0.8; 
                    }
                }
                group.userData.currentScale += (targetScale - group.userData.currentScale) * 0.1;
                group.scale.setScalar(group.userData.currentScale);

                group.updateMatrixWorld();
            });

            if (!isFocused) {
                // 非聚焦模式：使用全局旋转
                const sceneRotY = THREE.MathUtils.lerp(scene.rotation.y, targetRotationY, 0.05);
                const sceneRotX = THREE.MathUtils.lerp(scene.rotation.x, targetRotationX, 0.05);
                scene.rotation.y = sceneRotY;
                scene.rotation.x = sceneRotX;

                // 简单的视差
                camera.position.lerp(camTargetPos, 0.05);
                currentLookAt.lerp(camLookAtPos, 0.05);
                camera.lookAt(currentLookAt);
                camera.up.lerp(camTargetUp, 0.05);
                
                if (!isPanning) {
                     camera.position.x += (mouseX * 5 - (camera.position.x - camTargetPos.x)) * 0.01;
                     camera.position.y += (mouseY * 5 - (camera.position.y - camTargetPos.y)) * 0.01;
                }
            } else {
                // 聚焦模式：实时计算轨道摄像机位置
                if (focusedAlbum) {
                    
                    const worldPos = new THREE.Vector3();
                    focusedAlbum.getWorldPosition(worldPos);

                    const worldQuat = new THREE.Quaternion();
                    focusedAlbum.getWorldQuaternion(worldQuat);

                    // 计算轨道偏移
                    // 初始偏移是 (0, 0, 8)，即正前方
                    const offset = new THREE.Vector3(0, 0, 8);
                    
                    // 应用用户控制的旋转 (focusRotX, focusRotY)
                    // 这里使用欧拉角旋转向量，模拟云台
                    // 先绕X轴(上下)，再绕Y轴(左右)
                    offset.applyEuler(new THREE.Euler(focusRotX, focusRotY, 0, 'YXZ'));
                    
                    // 将局部偏移转换到卡片的世界空间方向
                    offset.applyQuaternion(worldQuat);

                    const targetPos = worldPos.clone().add(offset);
                    const targetUp = new THREE.Vector3(0, 1, 0).applyQuaternion(worldQuat); // 卡片的上方

                    // 平滑移动摄像机
                    camera.position.lerp(targetPos, 0.1);
                    camera.lookAt(worldPos); // 始终看向卡片中心
                    camera.up.lerp(targetUp, 0.1);
                }
            }

            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>